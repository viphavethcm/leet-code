Phân hoạch Lomuto:
lomuto_partition(A, low, high):
    pivot = A[right]         // chọn pivot là phần tử cuối
    i = left - 1             // i sẽ đánh dấu vị trí cuối cùng của phần tử < pivot
    for j = left to right:
        if A[j] <= pivot:
            i++
            swap A[i] with A[j]
    // cuối cùng đưa pivot về đúng chỗ (sau tất cả phần tử <= pivot)

    swap A[i + 1] with A[right]

    return i + 1            // vị trí mới của pivot

public static int lomuto_partition(int[] arr, int left, int right) {
      int pivot = arr[right];
      int i = left - 1;
      for (int j = left; j < right; j++) {
         if (arr[j] <= pivot) {
            i++;
            int tmp = arr[j];
            arr[j] = arr[i];
            arr[i] = tmp;
         }
      }
      i++;
      int tmp = arr[right];
      arr[right] = arr[i];
      arr[i] = tmp;
      return i;
   }

hoare partition(A, low, high)
    pivot = A[low]          // chọn pivot là phần tử đầu
        i = low - 1
        j = high + 1
        while true:
            repeat:
                i = i + 1
            until A[i] >= pivot
            repeat:
                j = j - 1
            until A[j] <= pivot
            if i >= j:
                return j        // vị trí phân hoạch
            swap A[i] with A[j]

public static void quickSort(int[] arr, int left, int right) {
   if (left < right) {
      int p = partition(arr, left, right);
      quickSort(arr, left, p - 1);
      quickSort(arr, p + 1, right);
   }
}